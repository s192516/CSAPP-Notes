## 2.3.8 Final Thoughts on Integer Arithmetic

总结起来就是算术运算也并不trivial，如前文中的for比较的bug，加减乘除溢出的判断，malloc调用unsigned的bug等等。

## 习题2.44

```
判断表达式是否返回1，假设int是32bit的，
int x = foo();
int y = bar();

unsigned ux = x;
unsigned uy = y;
```

A `(x > 0) || (x - 1 < 0)` 如果x是INT_MIN x - 1 会溢出，变成INT_MAX，然后不成立
B `(x & 7) != 7 || (x << 29 < 0 )` 正确
C `(x * x) >= 0` 不一定，假设x = 1 << 15 y = 1 << 16
D `x < 0 || -x <= 0` 正确
E `x > 0 || -x >= 0` 错误, 当x是INT_MIN是，-x会溢出成INT_MIN
F `x + y == uy + ux`错误，如果 x 和 y都是负数，那么结果一正一负显然不对 **答案为正确，bitlevel是一样的，结果会被强制转换我的理解**
G `x*~y + uy*ux == -x` 没懂，随便构造一个如果x为1,那么 ~y + uy == -1，如果y是负数就不成立了。 **答案为正确，x \* ~y  = x\* (-y - 1), uy\*ux=x\*y 经过运算后左边右边相等**

## 2.4 Floating Point

浮点数表达是如下的方法：`V=x*(2^y)`

## 2.4.1 Fractional Binary Numbers

这种表示方法不能精准的表示比如1/3或者5/7这种数，只能增加它的长度来逼近。

## 习题2.46 

浮点运算表达式的不精确会带来一些灾难性的影响，在第一次波斯湾战争中，美军爱国者未成功拦截导弹从而28人丧命，调查发现根本原因就是浮点数运算的不精准造成的。

A 0.1-x=0.(23个0)1 **答案为更精准的0.(23个0)[1100].., 最终的误差更大一点大概是1.5倍当前值即600多米**
B 1/(2^24) = 0.0000000596; 
C 实际每0.1s差1(2^24) 经过3600000 个0.1s后已经差了0.2s了。
D 那么相当于误差已经有400多米了

这样来看运算的精确度相当重要啊！


