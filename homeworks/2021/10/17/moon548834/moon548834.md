## 习题2.48

整数0x00359141h->0011 0101 1001 0001 0100 0001b

由于浮点数表达式是2^N*M。故可看作是: 1.101011001000101000001b * 2^21

float 表达式的N一共有8bit 加上偏移量127 应为 148

偏移量为148,最后再把末尾截取23位即可：

float 实际的值为0_10010100_10101100100010100000100

## 2.4.4 Rounding

![](./rounding.PNG)

实际上IEEE提供了4种不同的rounding的方式。round to even 是一个默认模式，需要注意的是，此时-1.5是向-2靠近而不是-1

Round even 是为了避免统计意义上的偏差，这样上取整和下取整是五五开

## 习题 2.50

我的理解是向小数点右侧一位取整

A 10.111(2) 11.0(2)
B 11.010(2) 11.0(2)
C 11.000(2) 11.0(2)
D 10.110(2) 11.0(2)

## 2.4.5 Floating-Point Operations

IEEE规范定义的浮点运算并不依赖特定的硬件或软件。需要注意的是**浮点数的运算并不具有结合律**，这对编译器等领域影响很大。

如编译器如果试图尝试做出以下优化:

```
x = a + b + c
y = b + c + d
```
优化至
```
t = b + c
x = a + t
y = t + d
```
就会有问题,最终x和y的数值可能就不一样了，并且没有分配率这个特性:`1e20*(1e20 - 1e20) == (0.0) != 1e20 *1e20 - 1e20 * 1e20 == NAN`
