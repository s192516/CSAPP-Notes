### 结构体

结构体是 C 语言中非常常用的一种机制，具体在内存中是如何存放的呢？我们通过具体的例子来进行学习。比如我们有这样一个结构体：

```
struct rec 
{
    int a[4];
    size_t i;       
    struct rect *next;
};
```

复制

那么在内存中的排列是

![img](https://wdxtub.com/images/csapp/14611816137150.jpg)

如果我们换一下结构体元素的排列顺序，可能就会出现和我们预想不一样的结果，比如

```
struct S1
{
    char c;
    int i[2];
    double v;
} *p;
```

复制

因为需要对齐的缘故，所以具体的排列是这样的：

![img](https://wdxtub.com/images/csapp/14611821730508.jpg)

具体对齐的原则是，如果数据类型需要 K 个字节，那么地址都必须是 K 的倍数，比方说这里 int 数组 i 需要是 4 的倍数，而 v 则需要是 8 的倍数。

感谢网友『光河』的补充：文中讲“具体对齐的原则是，如果数据类型需要 K 个字节，那么地址都必须是 K 的倍数”——这只是windows的原则，而Linux中的对齐策略是“2字节数据类型的地址必须为2的倍数，较大的数据类型（int,double,float）的地址必须是4的倍数”

为什么要这样呢，因为内存访问通常来说是 4 或者 8 个字节位单位的，不对齐的话访问起来效率不高。具体来看的话，是这样：

- 1 字节：char, …
  - 没有地址的限制
- 2 字节：short, …
  - 地址最低的 1 比特必须是 `0`
- 4 字节：int, float, …
  - 地址最低的 2 比特必须是 `00`
- 8 字节：double, long, char *, …
  - 地址最低的 3 比特必须是 `000`
- 16 字节：long double (GCC on Linux)
  - 地址最低的 4 比特必须是 `0000`

对于一个结构体来说，所占据的内存空间必须是最大的类型所需字节的倍数，所以可能需要占据更多的空间，比如：

```
struct S2 {
	double v;
	int i[2];
	char c;
} *p;
```

复制

![img](https://wdxtub.com/images/csapp/14611824112595.jpg)

根据这种特点，在设计结构体的时候可以采用一些技巧。例如，要把大的数据类型放到前面，加入我们有两个结构体：

```
struct S4 {
	char c;
	int i;
	char d;
} *p;

struct S5 {
	int i;
	char c;
	char d;
} *p;
```

复制

对应的排列是：

![img](https://wdxtub.com/images/csapp/14611827570059.jpg)

这样我们就通过不同的排列，节约了 4 个字节空间，如果这个结构体要被复制很多次，这也是很可观的内存优化。